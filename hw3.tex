\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,fancyhdr,parskip,amssymb,graphicx}
\usepackage[all]{xy}
\usepackage[margin = 1.5in]{geometry}
\pagestyle{fancy}
\lhead{Ben Carriel (bkc39)}
\chead{Bryan Cuccioli (blc72)}
\rhead{Andy Levine (awl58)}
\setlength{\parindent}{1cm}

\DeclareMathOperator{\Z}{\mathbb{Z}}
\DeclareMathOperator{\Q}{\mathbb{Q}}
\DeclareMathOperator{\R}{\mathbb{R}}
\DeclareMathOperator{\LP}{\mathrm{{\bf LP}}}

\DeclareMathOperator{\oh}{\mathcal{O}}
\DeclareMathOperator{\ta}{\xrightarrow{\ \ \ }}
\DeclareMathOperator{\opt}{\texttt{OPT}}

\newcommand{\problem}[1]{\noindent {\bf #1}}
\newcommand{\problempart}[1]{\noindent{\textbf{(#1)}}}

\newtheorem*{thm}{Theorem}
\newtheorem*{lem}{Lemma}
\newtheorem*{claim}{Claim}
\newtheorem*{defn}{Definition}
\newtheorem*{prop}{Proposition}

\begin{document}

\problem{Problem 1.}

The Ford-Fulkerson family of algorithms can be described as an instance of the simplex algorithm. Suppose we are given a network $G=(V,E)$ with source node $s\in V$ and sink $t\in V$, and edge capacity $c_{u,v}$ for each $(u,v)\in E$. We want to find
\[\max \sum_{(s,v)\in E} f(u,v)\]
subject to
\begin{enumerate}
\item $f(u,v)\leq c_{u,v}$ for all $(u,v)\in E$,
\item $f(u,v)\geq 0$ for every $(u,v)\in E$,
\item
\[\sum_{u:(u,v)\in E} f(u,v) - \sum_{w:(v,w)\in E} f(v,w) = 0\]
for every $v\in V\setminus\{s,t\}$.
\end{enumerate}

This is an LP and can be solved with the simplex algorithm. The augment step of the flow algorithm corresponds to the pivot step of the simplex algorithm. In the augment step in the flow algorithm, we are simply increasing the flow along a path until the constraint is broken at the bottleneck. In the pivot step of the simplex algorithm, we are simply increasing a variable until the constraint is broken, so it is clear that they are the same.

Furthering the analogy, when the pivots take place, the entering variable is the flow being pushed on the bottleneck edge, and the leaving variable is the flow on that edge in the residual graph, which is clear.

\problem{Problem 2.} 

\problempart{a} Here is the formulation of the multi-commodity flow problem as a linear program:
\begin{align*}
\min \sum_{e\in G} x_ep_e \\
\forall v \in G, \sum_{e = (u,v)} x_e = \sum_{e' = (v,w)} x_{e'} \\
\forall i, \sum_{e = (s_i, v)} x_e \geq C_i \\
\forall e \in G, x_e \geq 0
\end{align*}
To see that this formulation is correct we verify the following
\begin{claim}
The solution $\vec{x}$ to this linear program corresponds to the minimum bandwidth assignments in the given network problem. 
\end{claim}
\begin{proof}
TODO
\end{proof}

\problempart{b}
The primal LP is as follows

\begin{align*}
\min \sum_{e \in G} x_ep_e \\
\forall i, \forall (A,B) \text{ such that } s_i \in A, t_i \in B, \sum_{e \in A \times B} x_e \\
\forall e \in G,  x_e \geq 0
\end{align*}
The problem with this LP is that the number of cuts, and therefore the number of constraints, is exponential. To remedy this, we consider the dual LP given by
\begin{align*}
\max \sum_{e \in G} 
\end{align*}
\problem{Problem 3.}

\problempart{a} 

\problempart{b} In the worst case, our randomized algorithm swaps in all remaining $i$ constraints at the $n-i$ step. Therefore, for each constraint, the runtime is bounded by the sum
\[\sum_{i=1}^n \binom{n}{i} T(n-i).\]
Moreover, we have $T(n-i)<\log(n)T(n-(i+1))$, i.e. each $T(n)$ makes at most $\log(n)$ calls to the $T$ before it, so we have
\begin{align*}\sum_{i=1}^n \binom{n}{i} T(n-i)&<\sum_{i=1}^n \binom{n}{i}\log(n) T(n-(i+1))\\
&\hspace{2cm}\vdots\\
&<\sum_{i=1}^n \binom{n}{i} \prod_{j=1}^n \log(j)\\
&=\sum_{i=1}^n \binom{n}{i} \log\left(\sum_{j=1}^{n} j\right)\\
&=\sum_{i=1}^n \binom{n}{i} \log\left(\frac{n(n+1)}{2}\right)\\
&<2\sum_{i=1}^n \binom{n}{i} \log(n).\end{align*}

Moreover, we clearly have
\[\binom{n}{i}=\frac{n!}{i!(n-i)!}<\frac{(n\log n)!}{i!(n\log n - i)!} = \binom{n\log n}{i},\]
since we are adding in more factors to the numerator than the denominator. Therefore, we have
\[\sum_{i=1}^n \binom{n}{i} T(n-i) < 2\sum_{i=1}^n \binom{n\log n}{i} = 2\cdot 2^{n\log n} \in 2^{\mathcal{O}(n\log n)}.\]

\end{document}
