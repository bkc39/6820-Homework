\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,fancyhdr,parskip,amssymb,graphicx}
\usepackage[all]{xy}
\usepackage[margin = 1.5in]{geometry}
\pagestyle{fancy}
\lhead{Ben Carriel (bkc39)}
\chead{Bryan Cuccioli (blc72)}
\rhead{Andy Levine (awl58)}
\setlength{\parindent}{1cm}

\DeclareMathOperator{\Z}{\mathbb{Z}}
\DeclareMathOperator{\Q}{\mathbb{Q}}
\DeclareMathOperator{\R}{\mathbb{R}}

\DeclareMathOperator{\oh}{\mathcal{O}}
\DeclareMathOperator{\ta}{\xrightarrow{\ \ \ }}
\DeclareMathOperator{\opt}{\texttt{OPT}}

\newcommand{\problem}[1]{\noindent {\bf #1}}
\newcommand{\problempart}[1]{\noindent{\textbf{(#1)}}}

\newtheorem*{thm}{Theorem}
\newtheorem*{lem}{Lemma}
\newtheorem*{claim}{Claim}
\newtheorem*{defn}{Definition}
\newtheorem*{prop}{Proposition}

\begin{document}

\problem{Problem 1.}

The Ford-Fulkerson family of algorithms can be described as an instance of the simplex algorithm. Suppose we are given a network $G=(V,E)$ with source node $s\in V$ and sink $t\in V$, and edge capacity $c_{u,v}$ for each $(u,v)\in E$. We want to find
\[\max \sum_{(s,v)\in E} f(u,v)\]
subject to
\begin{enumerate}
\item $f(u,v)\leq c_{u,v}$ for all $(u,v)\in E$,
\item $f(u,v)\geq 0$ for every $(u,v)\in E$,
\item
\[\sum_{u:(u,v)\in E} f(u,v) - \sum_{w:(v,w)\in E} f(v,w) = 0\]
for every $v\in V\setminus\{s,t\}$.
\end{enumerate}

This is an LP and can be solved with the simplex algorithm. The augment step of the flow algorithm corresponds to the pivot step of the simplex algorithm. In the augment step in the flow algorithm, we are simply increasing the flow along a path until the constraint is broken at the bottleneck. In the pivot step of the simplex algorithm, we are simply increasing a variable until the constraint is broken, so it is clear that they are the same.

Furthering the analogy, when the pivots take place, the entering variable is the flow being pushed on the bottleneck edge, and the leaving variable is the flow on that edge in the residual graph, which is clear.

\problem{Problem 2.} 

\problempart{a} Here is the formulation of the multi-commodity flow problem as a linear program:
\begin{align*}
\min \sum_{e\in G} x_ep_e \\
\forall v \in G, \sum_{e = (u,v)} x_e = \sum_{e' = (v,w)} x_{e'} \\
\forall i, \sum_{e = (s_i, v)} x_e \geq C_i \\
\forall e \in G, x_e \geq 0
\end{align*}
To see that this formulation is correct we verify the following
\begin{claim}
The solution $\vec{x}$ to this linear program corresponds to the minimum bandwidth assignments in the given network problem. 
\end{claim}
\begin{proof}
TODO
\end{proof}

\problempart{b}
We begin by rephrasing the LP in terms of the cuts in the graph. 
\begin{align*}
\min \sum_{e \in G} x_ep_e \\
\forall i, \forall (A,B) \text{ such that } s_i \in A, t_i \in B, \sum_{e \in A \times B} x_e \\
\forall e \in G,  x_e \geq 0
\end{align*}
The problem with this LP is that the number of cuts, and therefore the number of constraints, is exponential. To remedy this, begin by ordering the subsets of $G$, by $S = \{G_1, G_2, \ldots, G_{2^{|G|}}\}$. Then we create dual variables $y_j$ for each of the subsets $S \times S$ that correspond to a valid cut in $G$ and let $\{S_j\}_{j=1}^k$ where $k$ is the number of cuts in $G$.  
\begin{align*}
\max \sum_{e \in G} y_j \\
\forall e \in G, \sum_{e \in S_j} \frac{y_j}{\mathcal{O}(j)} \leq p_e \\
y_j \geq 0 
\end{align*}
where $\mathcal{O}(j)$ is the maximum constraint $C_i$ that is imposed on the edge $e$. We have transposed the problem in such a way that we now have exponentially many variables, but polynomially many constraints. We now seek to apply the PST framework on this revised LP. We construct an oracle as follows:
\begin{align*}
\min \sum_{e\in E} w_e \sum_{e\in S_j} \frac{y_j}{p_e}\cdot \frac{1}{\mathcal{O}(j)} \\
\min \sum_{S_j} \frac{y_j}{\mathcal{O}_j} \sum_{e \in S_j} \frac{w_e}{p_e}
\end{align*}
The goal is to use to assign weights to each edge using the above oracle in an instance of HEDGE($\epsilon$). We then have the following subroutine

\begin{enumerate}
\item UPDATE
\item assign weights $w_i$ using HEDGE($\epsilon$)
\item assign $y_j$ to maximize $w^tAy$ where we can compute $y$ by running a max-flow algorithm (Dinic's) for each cut $S_j$
\item 
\item
\end{enumerate}
We then loop through the UPDATE step. 

\problem{Problem 3.}
\problempart{a} 

\problempart{b}
\end{document}
